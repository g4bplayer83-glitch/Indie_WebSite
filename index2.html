<!DOCTYPE html>
<html lang="fr">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Indie_WebsiteV2 - Accueil</title>
  <link rel="icon" type="image/x-icon" href="icon.ico">
  <style>
    body {
      margin: 0;
      padding: 0;
      background-color: #010023;
      color: #00ffff;
      font-family: Arial, sans-serif;
      overflow-x: hidden;
      text-align: center;
      scroll-behavior: smooth;
    }

    h1, h2, h3 {
      text-shadow: 0 0 20px #00ffff;
    }

    /* Style pour le titre */ 
    #mainTitle {
      cursor: pointer;
      transition: all 0.3s;
      text-shadow: 0 0 15px #00ffff, 0 0 30px #00ffff;
    }

    #mainTitle:hover {
      transform: scale(1.05);
    }

    /* Conteneur pour le texte animé */
    .moving-text-container {
      width: 100%;
      overflow: hidden;
      position: relative;
      height: 40px;
      display: flex;
      align-items: center;
    }

    /* Texte animé - apparaît à droite, sort à gauche */
    .moving-text {
      display: inline-block;
      white-space: nowrap;
      position: absolute;
      animation: scrollText 15s linear infinite;
    }

    @keyframes scrollText {
      0% { 
        left: 100%;
      }
      100% { 
        left: -100%;
      }
    }

    p {
      color: #ccfaff;
      line-height: 1.6em;
      max-width: 800px;
      margin: 10px auto;
    }

    a {
      color: #00ffff;
      text-decoration: none;
      border-bottom: 1px dotted #00ffff;
      transition: 0.3s;
      cursor: pointer;
    }

    a:hover {
      color: #000;
      background: #00ffff;
      padding: 2px 6px;
      border-radius: 6px;
    }

    /* Écran de démarrage */
    #startScreen {
      position: fixed;
      inset: 0;
      background: radial-gradient(circle, #001f2f, #000);
      display: flex;
      align-items: center;
      justify-content: center;
      flex-direction: column;
      z-index: 20;
      animation: fadeIn 1s ease;
    }

    #skipButton {
      position: absolute;
      bottom: 20px;
      right: 20px;
      padding: 8px 16px;
      background: rgba(0, 255, 255, 0.2);
      border: 1px solid #00ffff;
      color: #00ffff;
      border-radius: 8px;
      cursor: pointer;
      transition: all 0.3s;
      font-size: 0.9em;
      box-shadow: 0 0 10px rgba(0, 255, 255, 0.3);
    }

    #skipButton:hover {
      background: rgba(0, 255, 255, 0.4);
      box-shadow: 0 0 15px #00ffff;
      transform: scale(1.1);
    }

    @keyframes fadeIn { from { opacity: 0; } to { opacity: 1; } }
    @keyframes fadeOut { to { opacity: 0; visibility: hidden; } }
    @keyframes fadeInMain { to { opacity: 1; } }

    main {
      opacity: 0;
      animation: fadeInMain 1s ease forwards;
      padding: 30px;
      padding-bottom: 120px;
    }

    /* Contrôleur audio */
    #soundController {
      position: fixed;
      bottom: 20px;
      right: 20px;
      background: rgba(0, 20, 25, 0.8);
      border: 2px solid #00ffff;
      border-radius: 12px;
      box-shadow: 0 0 15px #00ffff;
      padding: 12px 16px;
      color: #00ffff;
      font-size: 0.9em;
      z-index: 5;
      display: flex;
      flex-direction: column;
      align-items: center;
      gap: 8px;
    }

    #soundController input[type=range] {
      width: 100px;
      accent-color: #00ffff;
    }

    img {
      border: 2px solid #00ffff;
      border-radius: 10px;
      margin: 15px;
      width: 300px;
      transition: transform 0.4s ease, box-shadow 0.4s ease;
      box-shadow: 0 0 10px rgba(0, 255, 255, 0.3);
    }

    img:hover {
      transform: scale(1.05);
      box-shadow: 0 0 30px #00ffff;
    }

    note {
      display: block;
      background: rgba(0, 255, 255, 0.1);
      border-left: 4px solid #00ffff;
      margin: 20px auto;
      max-width: 600px;
      padding: 10px 15px;
      font-style: italic;
      color: #aef6f6;
      box-shadow: 0 0 10px rgba(0, 255, 255, 0.2);
    }
    
    #tetrisButton {
      color: #00ffff;
      cursor: pointer;
      transition: all 0.2s;
      text-shadow: 0 0 5px #00ffff;
      font-weight: bold;
      font-style: normal;
    }
    
    #tetrisButton:hover {
      color: #fff;
      text-shadow: 0 0 15px #00ffff, 0 0 25px #00ffff;
      transform: scale(1.2);
      display: inline-block;
    }

    /* Modal Tetris */
    #tetrisModal {
      display: none;
      position: fixed;
      inset: 0;
      background: rgba(0, 0, 0, 0.95);
      z-index: 100;
      align-items: center;
      justify-content: center;
      animation: fadeIn 0.3s ease;
    }

    #tetrisModal.active {
      display: flex;
    }

    #tetrisContainer {
      position: relative;
      background: rgba(0, 20, 25, 0.9);
      border: 3px solid #00ffff;
      border-radius: 15px;
      padding: 20px;
      box-shadow: 0 0 40px #00ffff;
      display: flex;
      gap: 20px;
    }

    #closeButton {
      position: absolute;
      top: 10px;
      right: 10px;
      background: transparent;
      border: 2px solid #00ffff;
      color: #00ffff;
      width: 35px;
      height: 35px;
      border-radius: 50%;
      cursor: pointer;
      font-size: 1.2em;
      transition: all 0.3s;
    }

    #closeButton:hover {
      background: #00ffff;
      color: #000;
      transform: rotate(90deg);
    }

    #tetrisCanvas {
      border: 2px solid #00ffff;
      background: #000;
      display: block;
      box-shadow: 0 0 20px rgba(0, 255, 255, 0.3);
    }

    #nextPieceCanvas {
      border: 2px solid #00ffff;
      background: #000;
      display: block;
      box-shadow: 0 0 10px rgba(0, 255, 255, 0.3);
    }

    #tetrisInfo {
      color: #00ffff;
      text-align: center;
      margin-top: 15px;
      font-size: 1.1em;
    }

    #tetrisScore {
      margin-top: 10px;
      font-size: 1.3em;
      text-shadow: 0 0 10px #00ffff;
    }

    .tetris-sidebar {
      display: flex;
      flex-direction: column;
      justify-content: space-between;
    }

    .paragraphe-style {
      text-align: justify;
      text-justify: inter-word;
      line-height: 1.6;
      margin: 15px 0;
      padding: 10px;
      background-color: #4a41878b;
      border-left: 25px solid #527d99;
      box-shadow: 0 0 10px rgba(0, 255, 255, 0.2);
    }

    /* Zone de notes avec écriture et dessin */
    .notes-container {
      background: rgba(0, 255, 255, 0.1);
      border: 2px solid #00ffff;
      border-radius: 15px;
      padding: 20px;
      margin: 40px auto;
      max-width: 900px;
      box-shadow: 0 0 20px rgba(0, 255, 255, 0.4);
    }

    .notes-title {
      color: #00ffff;
      text-shadow: 0 0 10px #00ffff;
      border-bottom: 1px solid #00ffff;
      padding-bottom: 10px;
      margin-bottom: 20px;
    }

    .notes-content {
      display: flex;
      gap: 20px;
      min-height: 300px;
    }

    .text-notes {
      flex: 1;
      display: flex;
      flex-direction: column;
    }

    .drawing-notes {
      flex: 1;
      display: flex;
      flex-direction: column;
    }

    .notes-textarea {
      flex: 1;
      background: rgba(0, 0, 0, 0.5);
      border: 1px solid #00ffff;
      border-radius: 8px;
      color: #00ffff;
      padding: 15px;
      font-family: Arial, sans-serif;
      font-size: 14px;
      resize: none;
      outline: none;
    }

    .notes-textarea::placeholder {
      color: rgba(0, 255, 255, 0.5);
    }

    .drawing-canvas {
      flex: 1;
      background: rgba(0, 0, 0, 0.5);
      border: 1px solid #00ffff;
      border-radius: 8px;
      cursor: crosshair;
    }

    .drawing-controls {
      display: flex;
      gap: 10px;
      margin-top: 10px;
      justify-content: center;
    }

    .drawing-controls button {
      background: rgba(0, 255, 255, 0.2);
      border: 1px solid #00ffff;
      color: #00ffff;
      padding: 5px 10px;
      border-radius: 5px;
      cursor: pointer;
      transition: all 0.3s;
    }

    .drawing-controls button:hover {
      background: rgba(0, 255, 255, 0.4);
    }

    .color-picker {
      display: flex;
      gap: 5px;
      align-items: center;
    }

    .color-option {
      width: 20px;
      height: 20px;
      border-radius: 50%;
      cursor: pointer;
      border: 2px solid transparent;
    }

    .color-option.active {
      border-color: #fff;
    }

    /* Bouton de navigation */
    .nav-button {
      position: fixed;
      bottom: 20px;
      left: 20px;
      background: rgba(0, 255, 255, 0.2);
      border: 2px solid #00ffff;
      color: #00ffff;
      padding: 12px 20px;
      border-radius: 12px;
      cursor: pointer;
      transition: all 0.3s;
      font-size: 1em;
      box-shadow: 0 0 15px rgba(0, 255, 255, 0.3);
      z-index: 5;
    }

    .nav-button:hover {
      background: rgba(0, 255, 255, 0.4);
      box-shadow: 0 0 20px #00ffff;
      transform: scale(1.1);
    }

    /* Animation de particules pour Tetris */
    .tetris-particle {
      position: absolute;
      width: 4px;
      height: 4px;
      background: #00ffff;
      border-radius: 50%;
      pointer-events: none;
      opacity: 0.8;
      z-index: 101;
    }

    @keyframes particle-fall {
      0% {
        transform: translateY(0) scale(1);
        opacity: 1;
      }
      100% {
        transform: translateY(50px) scale(0);
        opacity: 0;
      }
    }

    /* Animation de chute rapide */
    @keyframes hard-drop {
      0% {
        opacity: 1;
      }
      50% {
        opacity: 0.5;
      }
      100% {
        opacity: 1;
      }
    }

    .hard-drop-animation {
      animation: hard-drop 0.3s ease;
    }
  </style>
</head>

<body>

  <!-- Écran de démarrage -->
  <div id="startScreen">
    <h1>Indie_WebsiteV2</h1>
    <p style="color:#00ffff;margin-bottom:20px;">Chargement en cours...</p>
    <button id="skipButton">⏩ Passer</button>
  </div>

  <!-- Musiques -->
  <audio id="introMusic" src="intro.wav"></audio>
  <audio id="bgMusic" src="music.wav" loop></audio>

  <!-- Effets -->
  <audio id="hoverSound" src="hover.wav"></audio>
  <audio id="clickSound" src="click.wav"></audio>

  <!-- Contenu principal -->
  <main>
    <h1 id="mainTitle">Bienvenue sur Indie_WebsiteV2</h1>
    <div class="moving-text-container">
      <h2 class="moving-text">Projet expérimental – Page HTML interactive</h2>
    </div>

    <p>
      Ce site explore les sons, les effets visuels et les animations synchronisées en HTML, CSS.
      Il offre une expérience immersive avec musique, vidéo et interactions.
    </p>

    <note>💡 Astuce : quand vous lisez la vidéo, la musique se coupe avec un fondu automatiquement, puis reprend ensuite.</note>

    <h3>Vidéo en vedette</h3>
    <video id="myVideo" width="480" height="270" controls>
      <source src="ULTRAKILL Montage - TEOAT.mp4" type="video/mp4">
      Votre navigateur ne supporte pas la vidéo.
    </video>

    <h3>Quelques liens utiles</h3>
    <p>
      🔗 <a id="scrollToImages" title="Descendre à la section des images">Voir les images plus bas</a><br>
      🌐 <a href="https://www.mozilla.org" target="_blank" title="Visitez Mozilla dans une nouvelle fenêtre">Visitez Mozilla</a>
    </p>

    <h1 style="color: #ff4444; margin-bottom: 10px; text-shadow: 0 0 10px rgba(255, 68, 68, 0.7);">ULTRAKILL - Le Jeu</h1>
    
    <p class="paragraphe-style">
      <strong>ULTRAKILL</strong> est un FPS (First-Person Shooter) développé par Arsi "Hakita" Patala, sorti en accès anticipé en 2020. Inspiré des jeux de tir classiques des années 90 comme <em>Quake</em> et <em>Doom</em>, il se distingue par son gameplay ultra-rapide, son style rétro et sa mécanique de combat innovante.
    </p>

    <p class="paragraphe-style">
      Le jeu se déroule dans un enfer post-apocalyptique où l'humanité a disparu. Vous incarnez V1, une machine alimentée par le sang, qui pénètre en enfer pour survivre. L'histoire est minimaliste mais profonde, explorant des thèmes comme la nature de la conscience et la moralité dans un monde sans humains.
    </p>

    <p class="paragraphe-style">
      La particularité d'<strong>ULTRAKILL</strong> réside dans son système de combat basé sur le style. Plus vous êtes agressif et varié dans vos attaques, plus vous gagnez de points de style. Le jeu encourage une approche "toujours en mouvement" avec des mécaniques comme le rebond sur les balles, les dashs aériens et les executions au corps à corps.
    </p>

    <p class="paragraphe-style">
      Avec sa bande-son metal industrielle énergique, ses visuels aux couleurs néon saisissantes et son gameplay frénétique, <strong>ULTRAKILL</strong> est devenu un titre culte dans la communauté des FPS indie. Il représente parfaitement la philosophie "gameplay first" et démontre comment un petit studio peut créer une expérience plus intense que beaucoup de jeux AAA.
    </p>

    <p class="paragraphe-style conclusion">
      En résumé, <strong>ULTRAKILL</strong> n'est pas juste un jeu de tir - c'est une symphonie de violence stylisée, un hommage aux classiques qui repousse les limites de ce que le genre FPS peut accomplir en termes de profondeur mécanique et de satisfaction pure.
    </p>

    <h3 id="images-section">Galerie d'images</h3>
    <p>Survolez les images pour voir un effet lumineux :</p>

    <img src="https://upload.wikimedia.org/wikipedia/commons/3/3a/Cat03.jpg" alt="Un chat mignon" title="Ceci est un chat 🐱">
    <img src="https://upload.wikimedia.org/wikipedia/commons/a/a9/Example.jpg" alt="Exemple d'image" title="Image d'exemple">

    <note>📝 Remarque : ce site est encore en développement. Cer<span id="tetrisButton" title="Jouer à Tetris">t</span>aines fonctions peuvent évoluer.</note>

    <!-- Zone de notes avec écriture et dessin -->
    <div class="notes-container">
      <h3 class="notes-title">📝 Zone de Notes Personnelles</h3>
      <div class="notes-content">
        <div class="text-notes">
          <h4>Écriture au clavier</h4>
          <textarea class="notes-textarea" placeholder="Écrivez vos notes ici..."></textarea>
        </div>
        <div class="drawing-notes">
          <h4>Dessin au stylet/souris</h4>
          <canvas class="drawing-canvas" width="400" height="250"></canvas>
          <div class="drawing-controls">
            <div class="color-picker">
              <div class="color-option active" style="background: #00ffff;" data-color="#00ffff"></div>
              <div class="color-option" style="background: #ffff00;" data-color="#ffff00"></div>
              <div class="color-option" style="background: #ff00ff;" data-color="#ff00ff"></div>
              <div class="color-option" style="background: #00ff00;" data-color="#00ff00"></div>
              <div class="color-option" style="background: #ffffff;" data-color="#ffffff"></div>
            </div>
            <button id="clearDrawing">Effacer</button>
            <button id="thickLine">Épais</button>
            <button id="thinLine">Fin</button>
          </div>
        </div>
      </div>
    </div>
  </main>

  <!-- Bouton de navigation -->
  <button class="nav-button" onclick="window.location.href='index3.html'">
    🎮 Histoire Nintendo
  </button>

  <!-- Modal Tetris -->
  <div id="tetrisModal">
    <div id="tetrisContainer">
      <button id="closeButton">×</button>
      <div>
        <canvas id="tetrisCanvas" width="200" height="360"></canvas>
        <div id="tetrisInfo">
          <div>Flèches : Déplacer | ↑ : Rotation | Espace : Chute rapide</div>
          <div id="tetrisScore">Score: 0</div>
        </div>
      </div>
      <div class="tetris-sidebar">
        <div>
          <h4 style="margin: 0 0 10px 0; text-shadow: 0 0 5px #00ffff;">Prochain:</h4>
          <canvas id="nextPieceCanvas" width="80" height="80"></canvas>
        </div>
        <div>
          <h4 style="margin: 10px 0; text-shadow: 0 0 5px #00ffff;">Contrôles:</h4>
          <p style="font-size: 0.8em; text-align: left; margin: 5px 0;">
            ← → : Déplacer<br>
            ↑ : Tourner<br>
            ↓ : Descendre<br>
            Espace : Poser
          </p>
        </div>
      </div>
    </div>
  </div>

  <!-- Contrôleur audio -->
  <div id="soundController">
    <button id="toggleMusic">⏸ Pause musique</button>
    <input type="range" id="volumeSlider" min="0" max="1" step="0.05" value="0.5">
    <div id="clock">--:--:--</div>
  </div>

  <script>
    // ===== INITIALISATION =====
    const startScreen = document.getElementById("startScreen");
    const skipButton = document.getElementById("skipButton");
    const introMusic = document.getElementById("introMusic");
    const bgMusic = document.getElementById("bgMusic");
    const hoverSound = document.getElementById("hoverSound");
    const clickSound = document.getElementById("clickSound");
    const vid = document.getElementById("myVideo");
    const toggleMusic = document.getElementById("toggleMusic");
    const volumeSlider = document.getElementById("volumeSlider");
    const clock = document.getElementById("clock");
    let isFading = false;

    // Vérifier si c'est un retour (pas de chargement)
    if (sessionStorage.getItem('returningUser')) {
      startScreen.style.display = 'none';
      document.querySelector('main').style.opacity = '1';
      document.querySelector('main').style.animation = 'none';
      bgMusic.volume = 0.5;
      bgMusic.play();
    } else {
      // Démarrage automatique avec skip direct
      window.addEventListener('load', () => {
        introMusic.volume = 0.6;
        bgMusic.volume = 0.5;
        introMusic.play();
        
        setTimeout(() => {
          skipIntro();
        }, 8000);
      });

      // Bouton skip avec transition directe
      skipButton.addEventListener("click", () => {
        playClick();
        skipIntro();
      });
    }

    function skipIntro() {
      fadeOutAudio(introMusic, 300);
      startScreen.style.animation = "fadeOut 0.8s forwards";
      setTimeout(() => {
        bgMusic.play();
        sessionStorage.setItem('returningUser', 'true');
      }, 500);
    }

    // Fade musique
    function fadeOutAudio(audio, duration = 500) {
      if (isFading) return;
      isFading = true;
      const step = audio.volume / (duration / 50);
      const fade = setInterval(() => {
        if (audio.volume > 0.05) {
          audio.volume -= step;
        } else {
          audio.volume = 0;
          audio.pause();
          clearInterval(fade);
          isFading = false;
        }
      }, 50);
    }

    function fadeInAudio(audio, targetVol = 0.5, duration = 1000) {
      if (isFading) return;
      isFading = true;
      audio.play();
      let vol = 0;
      audio.volume = 0;
      const step = targetVol / (duration / 50);
      const fade = setInterval(() => {
        if (vol < targetVol) {
          vol += step;
          audio.volume = vol;
        } else {
          audio.volume = targetVol;
          clearInterval(fade);
          isFading = false;
        }
      }, 50);
    }

    vid.addEventListener("play", () => fadeOutAudio(bgMusic, 1200));
    vid.addEventListener("pause", () => fadeInAudio(bgMusic, parseFloat(volumeSlider.value), 1200));
    vid.addEventListener("ended", () => fadeInAudio(bgMusic, parseFloat(volumeSlider.value), 1200));

    // Liens interactifs
    document.getElementById("scrollToImages").addEventListener("click", () => {
      document.getElementById("images-section").scrollIntoView({ behavior: "smooth" });
      playClick();
    });

    document.querySelectorAll("button").forEach(btn => {
      btn.addEventListener("mouseenter", () => {
        hoverSound.currentTime = 0;
        hoverSound.play();
      });
    });

    function playClick() {
      clickSound.currentTime = 0;
      clickSound.play();
    }

    // Musique / volume
    toggleMusic.addEventListener("click", () => {
      if (bgMusic.paused) {
        fadeInAudio(bgMusic, parseFloat(volumeSlider.value), 800);
        toggleMusic.textContent = "⏸ Pause musique";
      } else {
        fadeOutAudio(bgMusic, 800);
        toggleMusic.textContent = "▶ Reprendre musique";
      }
      playClick();
    });

    volumeSlider.addEventListener("input", () => {
      const vol = parseFloat(volumeSlider.value);
      bgMusic.volume = vol;
      introMusic.volume = vol;
    });

    // Horloge
    setInterval(() => clock.textContent = new Date().toLocaleTimeString(), 1000);

    // ===== TETRIS AMÉLIORÉ =====
    const tetrisButton = document.getElementById("tetrisButton");
    const tetrisModal = document.getElementById("tetrisModal");
    const closeButton = document.getElementById("closeButton");
    const canvas = document.getElementById("tetrisCanvas");
    const nextPieceCanvas = document.getElementById("nextPieceCanvas");
    const ctx = canvas.getContext("2d");
    const nextCtx = nextPieceCanvas.getContext("2d");
    const scoreDisplay = document.getElementById("tetrisScore");

    const ROWS = 18;
    const COLS = 10;
    const BLOCK_SIZE = 20;
    let board = [];
    let score = 0;
    let gameActive = false;
    let currentPiece = null;
    let nextPieceObj = null;
    let gameLoop = null;

    const SHAPES = [
      [[1,1,1,1]], // I
      [[1,1],[1,1]], // O
      [[0,1,0],[1,1,1]], // T
      [[1,0,0],[1,1,1]], // L
      [[0,0,1],[1,1,1]], // J
      [[0,1,1],[1,1,0]], // S
      [[1,1,0],[0,1,1]]  // Z
    ];

    const COLORS = ['#00ffff', '#ffff00', '#ff00ff', '#00ff00', '#ff8800', '#ff0000', '#0088ff'];

    function initBoard() {
      board = Array(ROWS).fill().map(() => Array(COLS).fill(0));
      score = 0;
      scoreDisplay.textContent = `Score: ${score}`;
    }

    function drawBoard() {
      ctx.fillStyle = '#000';
      ctx.fillRect(0, 0, canvas.width, canvas.height);
      
      // Dessiner la ligne de projection
      if (gameActive && currentPiece) {
        const dropDistance = calculateDropDistance();
        if (dropDistance > 0) {
          ctx.strokeStyle = 'rgba(0, 255, 255, 0.3)';
          ctx.lineWidth = 1;
          ctx.setLineDash([5, 5]);
          currentPiece.shape.forEach((row, r) => {
            row.forEach((cell, c) => {
              if (cell) {
                const x = (currentPiece.x + c) * BLOCK_SIZE;
                const y = (currentPiece.y + r + dropDistance) * BLOCK_SIZE;
                ctx.strokeRect(x, y, BLOCK_SIZE - 1, BLOCK_SIZE - 1);
              }
            });
          });
          ctx.setLineDash([]);
        }
      }
      
      for (let r = 0; r < ROWS; r++) {
        for (let c = 0; c < COLS; c++) {
          if (board[r][c]) {
            ctx.fillStyle = COLORS[board[r][c] - 1];
            ctx.fillRect(c * BLOCK_SIZE, r * BLOCK_SIZE, BLOCK_SIZE - 1, BLOCK_SIZE - 1);
            ctx.strokeStyle = '#00ffff';
            ctx.lineWidth = 1;
            ctx.strokeRect(c * BLOCK_SIZE, r * BLOCK_SIZE, BLOCK_SIZE - 1, BLOCK_SIZE - 1);
          }
        }
      }

      if (currentPiece) {
        ctx.fillStyle = COLORS[currentPiece.color];
        currentPiece.shape.forEach((row, r) => {
          row.forEach((cell, c) => {
            if (cell) {
              const x = (currentPiece.x + c) * BLOCK_SIZE;
              const y = (currentPiece.y + r) * BLOCK_SIZE;
              ctx.fillRect(x, y, BLOCK_SIZE - 1, BLOCK_SIZE - 1);
              ctx.strokeStyle = '#00ffff';
              ctx.strokeRect(x, y, BLOCK_SIZE - 1, BLOCK_SIZE - 1);
            }
          });
        });
      }
    }

    function calculateDropDistance() {
      let dropDistance = 0;
      while (!collides(currentPiece, 0, dropDistance + 1)) {
        dropDistance++;
      }
      return dropDistance;
    }

    function drawNextPiece() {
      nextCtx.fillStyle = '#000';
      nextCtx.fillRect(0, 0, nextPieceCanvas.width, nextPieceCanvas.height);
      
      if (nextPieceObj) {
        const offsetX = (nextPieceCanvas.width - nextPieceObj.shape[0].length * BLOCK_SIZE/2) / 2;
        const offsetY = (nextPieceCanvas.height - nextPieceObj.shape.length * BLOCK_SIZE/2) / 2;
        
        nextCtx.fillStyle = COLORS[nextPieceObj.color];
        nextPieceObj.shape.forEach((row, r) => {
          row.forEach((cell, c) => {
            if (cell) {
              const x = offsetX + c * BLOCK_SIZE/2;
              const y = offsetY + r * BLOCK_SIZE/2;
              nextCtx.fillRect(x, y, BLOCK_SIZE/2 - 1, BLOCK_SIZE/2 - 1);
              nextCtx.strokeStyle = '#00ffff';
              nextCtx.strokeRect(x, y, BLOCK_SIZE/2 - 1, BLOCK_SIZE/2 - 1);
            }
          });
        });
      }
    }

    function createPiece() {
      const shapeIndex = Math.floor(Math.random() * SHAPES.length);
      return {
        shape: SHAPES[shapeIndex],
        color: shapeIndex,
        x: Math.floor(COLS / 2) - 1,
        y: 0
      };
    }

    function collides(piece, offsetX = 0, offsetY = 0) {
      for (let r = 0; r < piece.shape.length; r++) {
        for (let c = 0; c < piece.shape[r].length; c++) {
          if (piece.shape[r][c]) {
            const newX = piece.x + c + offsetX;
            const newY = piece.y + r + offsetY;
            if (newX < 0 || newX >= COLS || newY >= ROWS) return true;
            if (newY >= 0 && board[newY][newX]) return true;
          }
        }
      }
      return false;
    }

    // Fonction pour créer des particules
    function createParticles(x, y, count = 8) {
      for (let i = 0; i < count; i++) {
        const particle = document.createElement('div');
        particle.className = 'tetris-particle';
        particle.style.left = `${x}px`;
        particle.style.top = `${y}px`;
        document.body.appendChild(particle);
        
        const angle = Math.random() * Math.PI * 2;
        const distance = Math.random() * 30 + 10;
        const targetX = x + Math.cos(angle) * distance;
        const targetY = y + Math.sin(angle) * distance;
        
        particle.style.animation = `particle-fall ${Math.random() * 0.5 + 0.3}s ease forwards`;
        particle.style.left = `${targetX}px`;
        
        setTimeout(() => {
          if (particle.parentNode) {
            particle.parentNode.removeChild(particle);
          }
        }, 500);
      }
    }

    function mergePiece() {
      // Créer des particules à chaque bloc posé
      currentPiece.shape.forEach((row, r) => {
        row.forEach((cell, c) => {
          if (cell) {
            const y = currentPiece.y + r;
            const x = currentPiece.x + c;
            if (y >= 0) {
              board[y][x] = currentPiece.color + 1;
              // Créer des particules à la position du bloc
              const canvasRect = canvas.getBoundingClientRect();
              const particleX = canvasRect.left + x * BLOCK_SIZE + BLOCK_SIZE/2;
              const particleY = canvasRect.top + y * BLOCK_SIZE + BLOCK_SIZE/2;
              createParticles(particleX, particleY, 3);
            }
          }
        });
      });
    }

    function clearLines() {
      let linesCleared = 0;
      for (let r = ROWS - 1; r >= 0; r--) {
        if (board[r].every(cell => cell !== 0)) {
          // Créer plus de particules pour une ligne complète
          for (let c = 0; c < COLS; c++) {
            const canvasRect = canvas.getBoundingClientRect();
            const particleX = canvasRect.left + c * BLOCK_SIZE + BLOCK_SIZE/2;
            const particleY = canvasRect.top + r * BLOCK_SIZE + BLOCK_SIZE/2;
            createParticles(particleX, particleY, 5);
          }
          
          board.splice(r, 1);
          board.unshift(Array(COLS).fill(0));
          linesCleared++;
          r++;
        }
      }
      if (linesCleared > 0) {
        score += linesCleared * 100;
        scoreDisplay.textContent = `Score: ${score}`;
      }
    }

    function rotatePiece() {
      const rotated = currentPiece.shape[0].map((_, i) =>
        currentPiece.shape.map(row => row[i]).reverse()
      );
      const oldShape = currentPiece.shape;
      currentPiece.shape = rotated;
      if (collides(currentPiece)) {
        currentPiece.shape = oldShape;
      }
    }

    function hardDrop() {
      // Animation de flash
      canvas.classList.add('hard-drop-animation');
      setTimeout(() => {
        canvas.classList.remove('hard-drop-animation');
      }, 300);
      
      const dropDistance = calculateDropDistance();
      currentPiece.y += dropDistance;
      mergePiece();
      clearLines();
      currentPiece = nextPieceObj;
      nextPieceObj = createPiece();
      drawNextPiece();
      
      if (collides(currentPiece)) {
        gameActive = false;
        clearInterval(gameLoop);
        alert(`Game Over! Score: ${score}`);
        tetrisModal.classList.remove("active");
      }
    }

    function gameStep() {
      if (!collides(currentPiece, 0, 1)) {
        currentPiece.y++;
      } else {
        mergePiece();
        clearLines();
        currentPiece = nextPieceObj;
        nextPieceObj = createPiece();
        drawNextPiece();
        if (collides(currentPiece)) {
          gameActive = false;
          clearInterval(gameLoop);
          alert(`Game Over! Score: ${score}`);
          tetrisModal.classList.remove("active");
        }
      }
      drawBoard();
    }

    function startGame() {
      initBoard();
      currentPiece = createPiece();
      nextPieceObj = createPiece();
      gameActive = true;
      drawBoard();
      drawNextPiece();
      gameLoop = setInterval(gameStep, 500);
    }

    tetrisButton.addEventListener("click", () => {
      playClick();
      tetrisModal.classList.add("active");
      startGame();
    });

    closeButton.addEventListener("click", () => {
      playClick();
      tetrisModal.classList.remove("active");
      gameActive = false;
      if (gameLoop) clearInterval(gameLoop);
    });

    document.addEventListener("keydown", (e) => {
      if (!gameActive) return;
      
      // Empêcher le scroll de la page avec les flèches
      if (["ArrowLeft", "ArrowRight", "ArrowDown", "ArrowUp", " "].includes(e.key)) {
        e.preventDefault();
      }
      
      if (e.key === "ArrowLeft" && !collides(currentPiece, -1, 0)) {
        currentPiece.x--;
      } else if (e.key === "ArrowRight" && !collides(currentPiece, 1, 0)) {
        currentPiece.x++;
      } else if (e.key === "ArrowDown" && !collides(currentPiece, 0, 1)) {
        currentPiece.y++;
      } else if (e.key === "ArrowUp") {
        rotatePiece();
      } else if (e.key === " ") {
        hardDrop();
      }
      drawBoard();
    });

    tetrisModal.addEventListener("click", (e) => {
      if (e.target === tetrisModal) {
        tetrisModal.classList.remove("active");
        gameActive = false;
        if (gameLoop) clearInterval(gameLoop);
      }
    });

    // ===== ZONE DE NOTES AVEC DESSIN =====
    const drawingCanvas = document.querySelector('.drawing-canvas');
    const drawingCtx = drawingCanvas.getContext('2d');
    const clearButton = document.getElementById('clearDrawing');
    const thickButton = document.getElementById('thickLine');
    const thinButton = document.getElementById('thinLine');
    const colorOptions = document.querySelectorAll('.color-option');
    
    let isDrawing = false;
    let lastX = 0;
    let lastY = 0;
    let currentColor = '#00ffff';
    let lineWidth = 2;

    // Initialiser le canvas de dessin
    drawingCtx.fillStyle = 'rgba(0, 0, 0, 0.5)';
    drawingCtx.fillRect(0, 0, drawingCanvas.width, drawingCanvas.height);
    drawingCtx.lineJoin = 'round';
    drawingCtx.lineCap = 'round';
    drawingCtx.strokeStyle = currentColor;
    drawingCtx.lineWidth = lineWidth;

    // Événements de dessin
    drawingCanvas.addEventListener('mousedown', startDrawing);
    drawingCanvas.addEventListener('mousemove', draw);
    drawingCanvas.addEventListener('mouseup', stopDrawing);
    drawingCanvas.addEventListener('mouseout', stopDrawing);

    // Support pour les stylets (touch)
    drawingCanvas.addEventListener('touchstart', handleTouch);
    drawingCanvas.addEventListener('touchmove', handleTouch);
    drawingCanvas.addEventListener('touchend', stopDrawing);

    function handleTouch(e) {
      e.preventDefault();
      const touch = e.touches[0];
      const mouseEvent = new MouseEvent('mousedown', {
        clientX: touch.clientX,
        clientY: touch.clientY
      });
      drawingCanvas.dispatchEvent(mouseEvent);
    }

    function startDrawing(e) {
      isDrawing = true;
      [lastX, lastY] = [e.offsetX, e.offsetY];
    }

    function draw(e) {
      if (!isDrawing) return;
      
      drawingCtx.beginPath();
      drawingCtx.moveTo(lastX, lastY);
      drawingCtx.lineTo(e.offsetX, e.offsetY);
      drawingCtx.stroke();
      
      [lastX, lastY] = [e.offsetX, e.offsetY];
    }

    function stopDrawing() {
      isDrawing = false;
    }

    // Contrôles de dessin
    clearButton.addEventListener('click', () => {
      drawingCtx.fillStyle = 'rgba(0, 0, 0, 0.5)';
      drawingCtx.fillRect(0, 0, drawingCanvas.width, drawingCanvas.height);
    });

    thickButton.addEventListener('click', () => {
      lineWidth = 5;
      drawingCtx.lineWidth = lineWidth;
    });

    thinButton.addEventListener('click', () => {
      lineWidth = 2;
      drawingCtx.lineWidth = lineWidth;
    });

    colorOptions.forEach(option => {
      option.addEventListener('click', () => {
        colorOptions.forEach(opt => opt.classList.remove('active'));
        option.classList.add('active');
        currentColor = option.dataset.color;
        drawingCtx.strokeStyle = currentColor;
      });
    });

    // ===== EFFET DE FLOU GRADUEL EN BAS =====
    class GradualBlur {
      constructor(options = {}) {
        this.position = options.position || 'bottom';
        this.strength = options.strength || 3;
        this.init();
      }
      
      init() {
        const overlay = document.createElement('div');
        overlay.style.position = 'fixed';
        overlay.style.left = '0';
        overlay.style.right = '0';
        overlay.style.height = '100px';
        overlay.style.pointerEvents = 'none';
        overlay.style.zIndex = '999';
        
        if (this.position === 'bottom') {
          overlay.style.bottom = '0';
          overlay.style.background = 'linear-gradient(to top, rgba(11,11,11,0.8), transparent)';
        } else {
          overlay.style.top = '0';
          overlay.style.background = 'linear-gradient(to bottom, rgba(11,11,11,0.8), transparent)';
        }
        
        document.body.appendChild(overlay);
      }
    }

    // Initialiser l'effet de flou
    const pageBlur = new GradualBlur({
      position: 'bottom',
      strength: 2
    });

    console.log('✨ Site chargé avec succès !');
  </script>
</body>
</html>
