<!DOCTYPE html>
<html lang="fr">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Indie_WebsiteV2 - Accueil</title>
  <link rel="icon" type="image/x-icon" href="icon.ico">
  <style>
    body {
      margin: 0;
      padding: 0;
      background-color: #010023;
      color: #00ffff;
      font-family: Arial, sans-serif;
      overflow-x: hidden;
      text-align: center;
      scroll-behavior: smooth;
    }

    h1, h2, h3 {
      text-shadow: 0 0 20px #00ffff;
    }

    /* Style pour le titre */ 
    #mainTitle {
      cursor: pointer;
      transition: all 0.3s;
      text-shadow: 0 0 15px #00ffff, 0 0 30px #00ffff;
    }

    #mainTitle:hover {
      transform: scale(1.05);
    }

    /* Conteneur pour le texte anim√© */
    .moving-text-container {
      width: 100%;
      overflow: hidden;
      position: relative;
      height: 40px;
      display: flex;
      align-items: center;
    }

    /* Texte anim√© - appara√Æt √† droite, sort √† gauche */
    .moving-text {
      display: inline-block;
      white-space: nowrap;
      position: absolute;
      animation: scrollText 15s linear infinite;
    }

    @keyframes scrollText {
      0% { 
        left: 100%;
      }
      100% { 
        left: -100%;
      }
    }

    p {
      color: #ccfaff;
      line-height: 1.6em;
      max-width: 800px;
      margin: 10px auto;
    }

    a {
      color: #00ffff;
      text-decoration: none;
      border-bottom: 1px dotted #00ffff;
      transition: 0.3s;
      cursor: pointer;
    }

    a:hover {
      color: #000;
      background: #00ffff;
      padding: 2px 6px;
      border-radius: 6px;
    }

    /* √âcran de d√©marrage */
    #startScreen {
      position: fixed;
      inset: 0;
      background: radial-gradient(circle, #001f2f, #000);
      display: flex;
      align-items: center;
      justify-content: center;
      flex-direction: column;
      z-index: 20;
      animation: fadeIn 1s ease;
    }

    #skipButton {
      position: absolute;
      bottom: 20px;
      right: 20px;
      padding: 8px 16px;
      background: rgba(0, 255, 255, 0.2);
      border: 1px solid #00ffff;
      color: #00ffff;
      border-radius: 8px;
      cursor: pointer;
      transition: all 0.3s;
      font-size: 0.9em;
      box-shadow: 0 0 10px rgba(0, 255, 255, 0.3);
    }

    #skipButton:hover {
      background: rgba(0, 255, 255, 0.4);
      box-shadow: 0 0 15px #00ffff;
      transform: scale(1.1);
    }

    @keyframes fadeIn { from { opacity: 0; } to { opacity: 1; } }
    @keyframes fadeOut { to { opacity: 0; visibility: hidden; } }
    @keyframes fadeInMain { to { opacity: 1; } }

    main {
      opacity: 0;
      animation: fadeInMain 1s ease forwards;
      padding: 30px;
      padding-bottom: 120px;
    }

    /* Contr√¥leur audio */
    #soundController {
      position: fixed;
      bottom: 20px;
      right: 20px;
      background: rgba(0, 20, 25, 0.8);
      border: 2px solid #00ffff;
      border-radius: 12px;
      box-shadow: 0 0 15px #00ffff;
      padding: 12px 16px;
      color: #00ffff;
      font-size: 0.9em;
      z-index: 5;
      display: flex;
      flex-direction: column;
      align-items: center;
      gap: 8px;
    }

    #soundController input[type=range] {
      width: 100px;
      accent-color: #00ffff;
    }

    img {
      border: 2px solid #00ffff;
      border-radius: 10px;
      margin: 15px;
      width: 300px;
      transition: transform 0.4s ease, box-shadow 0.4s ease;
      box-shadow: 0 0 10px rgba(0, 255, 255, 0.3);
    }

    img:hover {
      transform: scale(1.05);
      box-shadow: 0 0 30px #00ffff;
    }

    note {
      display: block;
      background: rgba(0, 255, 255, 0.1);
      border-left: 4px solid #00ffff;
      margin: 20px auto;
      max-width: 600px;
      padding: 10px 15px;
      font-style: italic;
      color: #aef6f6;
      box-shadow: 0 0 10px rgba(0, 255, 255, 0.2);
    }
    
    #tetrisButton {
      color: #00ffff;
      cursor: pointer;
      transition: all 0.2s;
      text-shadow: 0 0 5px #00ffff;
      font-weight: bold;
      font-style: normal;
    }
    
    #tetrisButton:hover {
      color: #fff;
      text-shadow: 0 0 15px #00ffff, 0 0 25px #00ffff;
      transform: scale(1.2);
      display: inline-block;
    }

    /* Modal Tetris */
    #tetrisModal {
      display: none;
      position: fixed;
      inset: 0;
      background: rgba(0, 0, 0, 0.95);
      z-index: 100;
      align-items: center;
      justify-content: center;
      animation: fadeIn 0.3s ease;
    }

    #tetrisModal.active {
      display: flex;
    }

    #tetrisContainer {
      position: relative;
      background: rgba(0, 20, 25, 0.9);
      border: 3px solid #00ffff;
      border-radius: 15px;
      padding: 20px;
      box-shadow: 0 0 40px #00ffff;
      display: flex;
      gap: 20px;
    }

    #closeButton {
      position: absolute;
      top: 10px;
      right: 10px;
      background: transparent;
      border: 2px solid #00ffff;
      color: #00ffff;
      width: 35px;
      height: 35px;
      border-radius: 50%;
      cursor: pointer;
      font-size: 1.2em;
      transition: all 0.3s;
    }

    #closeButton:hover {
      background: #00ffff;
      color: #000;
      transform: rotate(90deg);
    }

    #tetrisCanvas {
      border: 2px solid #00ffff;
      background: #000;
      display: block;
      box-shadow: 0 0 20px rgba(0, 255, 255, 0.3);
    }

    #nextPieceCanvas {
      border: 2px solid #00ffff;
      background: #000;
      display: block;
      box-shadow: 0 0 10px rgba(0, 255, 255, 0.3);
    }

    #tetrisInfo {
      color: #00ffff;
      text-align: center;
      margin-top: 15px;
      font-size: 1.1em;
    }

    #tetrisScore {
      margin-top: 10px;
      font-size: 1.3em;
      text-shadow: 0 0 10px #00ffff;
    }

    .tetris-sidebar {
      display: flex;
      flex-direction: column;
      justify-content: space-between;
    }

    .paragraphe-style {
      text-align: justify;
      text-justify: inter-word;
      line-height: 1.6;
      margin: 15px 0;
      padding: 10px;
      background-color: #4a41878b;
      border-left: 25px solid #527d99;
      box-shadow: 0 0 10px rgba(0, 255, 255, 0.2);
    }

    /* Zone de notes avec √©criture et dessin */
    .notes-container {
      background: rgba(0, 255, 255, 0.1);
      border: 2px solid #00ffff;
      border-radius: 15px;
      padding: 20px;
      margin: 40px auto;
      max-width: 900px;
      box-shadow: 0 0 20px rgba(0, 255, 255, 0.4);
    }

    .notes-title {
      color: #00ffff;
      text-shadow: 0 0 10px #00ffff;
      border-bottom: 1px solid #00ffff;
      padding-bottom: 10px;
      margin-bottom: 20px;
    }

    .notes-content {
      display: flex;
      gap: 20px;
      min-height: 300px;
    }

    .text-notes {
      flex: 1;
      display: flex;
      flex-direction: column;
    }

    .drawing-notes {
      flex: 1;
      display: flex;
      flex-direction: column;
    }

    .notes-textarea {
      flex: 1;
      background: rgba(0, 0, 0, 0.5);
      border: 1px solid #00ffff;
      border-radius: 8px;
      color: #00ffff;
      padding: 15px;
      font-family: Arial, sans-serif;
      font-size: 14px;
      resize: none;
      outline: none;
    }

    .notes-textarea::placeholder {
      color: rgba(0, 255, 255, 0.5);
    }

    .drawing-canvas {
      flex: 1;
      background: rgba(0, 0, 0, 0.5);
      border: 1px solid #00ffff;
      border-radius: 8px;
      cursor: crosshair;
    }

    .drawing-controls {
      display: flex;
      gap: 10px;
      margin-top: 10px;
      justify-content: center;
    }

    .drawing-controls button {
      background: rgba(0, 255, 255, 0.2);
      border: 1px solid #00ffff;
      color: #00ffff;
      padding: 5px 10px;
      border-radius: 5px;
      cursor: pointer;
      transition: all 0.3s;
    }

    .drawing-controls button:hover {
      background: rgba(0, 255, 255, 0.4);
    }

    .color-picker {
      display: flex;
      gap: 5px;
      align-items: center;
    }

    .color-option {
      width: 20px;
      height: 20px;
      border-radius: 50%;
      cursor: pointer;
      border: 2px solid transparent;
    }

    .color-option.active {
      border-color: #fff;
    }

    /* Bouton de navigation */
    .nav-button {
      position: fixed;
      bottom: 20px;
      left: 20px;
      background: rgba(0, 255, 255, 0.2);
      border: 2px solid #00ffff;
      color: #00ffff;
      padding: 12px 20px;
      border-radius: 12px;
      cursor: pointer;
      transition: all 0.3s;
      font-size: 1em;
      box-shadow: 0 0 15px rgba(0, 255, 255, 0.3);
      z-index: 5;
    }

    .nav-button:hover {
      background: rgba(0, 255, 255, 0.4);
      box-shadow: 0 0 20px #00ffff;
      transform: scale(1.1);
    }

    /* Animation de particules pour Tetris */
    .tetris-particle {
      position: absolute;
      width: 4px;
      height: 4px;
      background: #00ffff;
      border-radius: 50%;
      pointer-events: none;
      opacity: 0.8;
      z-index: 101;
    }

    @keyframes particle-fall {
      0% {
        transform: translateY(0) scale(1);
        opacity: 1;
      }
      100% {
        transform: translateY(50px) scale(0);
        opacity: 0;
      }
    }

    /* Animation de chute rapide */
    @keyframes hard-drop {
      0% {
        opacity: 1;
      }
      50% {
        opacity: 0.5;
      }
      100% {
        opacity: 1;
      }
    }

    .hard-drop-animation {
      animation: hard-drop 0.3s ease;
    }
  </style>
</head>

<body>

  <!-- √âcran de d√©marrage -->
  <div id="startScreen">
    <h1>Indie_WebsiteV2</h1>
    <p style="color:#00ffff;margin-bottom:20px;">Chargement en cours...</p>
    <button id="skipButton">‚è© Passer</button>
  </div>

  <!-- Musiques -->
  <audio id="introMusic" src="intro.wav"></audio>
  <audio id="bgMusic" src="music.wav" loop></audio>

  <!-- Effets -->
  <audio id="hoverSound" src="hover.wav"></audio>
  <audio id="clickSound" src="click.wav"></audio>

  <!-- Contenu principal -->
  <main>
    <h1 id="mainTitle">Bienvenue sur Indie_WebsiteV2</h1>
    <div class="moving-text-container">
      <h2 class="moving-text">Projet exp√©rimental ‚Äì Page HTML interactive</h2>
    </div>

    <p>
      Ce site explore les sons, les effets visuels et les animations synchronis√©es en HTML, CSS.
      Il offre une exp√©rience immersive avec musique, vid√©o et interactions.
    </p>

    <note>üí° Astuce : quand vous lisez la vid√©o, la musique se coupe avec un fondu automatiquement, puis reprend ensuite.</note>

    <h3>Vid√©o en vedette</h3>
    <video id="myVideo" width="480" height="270" controls>
      <source src="ULTRAKILL Montage - TEOAT.mp4" type="video/mp4">
      Votre navigateur ne supporte pas la vid√©o.
    </video>

    <h3>Quelques liens utiles</h3>
    <p>
      üîó <a id="scrollToImages" title="Descendre √† la section des images">Voir les images plus bas</a><br>
      üåê <a href="https://www.mozilla.org" target="_blank" title="Visitez Mozilla dans une nouvelle fen√™tre">Visitez Mozilla</a>
    </p>

    <h1 style="color: #ff4444; margin-bottom: 10px; text-shadow: 0 0 10px rgba(255, 68, 68, 0.7);">ULTRAKILL - Le Jeu</h1>
    
    <p class="paragraphe-style">
      <strong>ULTRAKILL</strong> est un FPS (First-Person Shooter) d√©velopp√© par Arsi "Hakita" Patala, sorti en acc√®s anticip√© en 2020. Inspir√© des jeux de tir classiques des ann√©es 90 comme <em>Quake</em> et <em>Doom</em>, il se distingue par son gameplay ultra-rapide, son style r√©tro et sa m√©canique de combat innovante.
    </p>

    <p class="paragraphe-style">
      Le jeu se d√©roule dans un enfer post-apocalyptique o√π l'humanit√© a disparu. Vous incarnez V1, une machine aliment√©e par le sang, qui p√©n√®tre en enfer pour survivre. L'histoire est minimaliste mais profonde, explorant des th√®mes comme la nature de la conscience et la moralit√© dans un monde sans humains.
    </p>

    <p class="paragraphe-style">
      La particularit√© d'<strong>ULTRAKILL</strong> r√©side dans son syst√®me de combat bas√© sur le style. Plus vous √™tes agressif et vari√© dans vos attaques, plus vous gagnez de points de style. Le jeu encourage une approche "toujours en mouvement" avec des m√©caniques comme le rebond sur les balles, les dashs a√©riens et les executions au corps √† corps.
    </p>

    <p class="paragraphe-style">
      Avec sa bande-son metal industrielle √©nergique, ses visuels aux couleurs n√©on saisissantes et son gameplay fr√©n√©tique, <strong>ULTRAKILL</strong> est devenu un titre culte dans la communaut√© des FPS indie. Il repr√©sente parfaitement la philosophie "gameplay first" et d√©montre comment un petit studio peut cr√©er une exp√©rience plus intense que beaucoup de jeux AAA.
    </p>

    <p class="paragraphe-style conclusion">
      En r√©sum√©, <strong>ULTRAKILL</strong> n'est pas juste un jeu de tir - c'est une symphonie de violence stylis√©e, un hommage aux classiques qui repousse les limites de ce que le genre FPS peut accomplir en termes de profondeur m√©canique et de satisfaction pure.
    </p>

    <h3 id="images-section">Galerie d'images</h3>
    <p>Survolez les images pour voir un effet lumineux :</p>

    <img src="https://upload.wikimedia.org/wikipedia/commons/3/3a/Cat03.jpg" alt="Un chat mignon" title="Ceci est un chat üê±">
    <img src="https://upload.wikimedia.org/wikipedia/commons/a/a9/Example.jpg" alt="Exemple d'image" title="Image d'exemple">

    <note>üìù Remarque : ce site est encore en d√©veloppement. Cer<span id="tetrisButton" title="Jouer √† Tetris">t</span>aines fonctions peuvent √©voluer.</note>

    <!-- Zone de notes avec √©criture et dessin -->
    <div class="notes-container">
      <h3 class="notes-title">üìù Zone de Notes Personnelles</h3>
      <div class="notes-content">
        <div class="text-notes">
          <h4>√âcriture au clavier</h4>
          <textarea class="notes-textarea" placeholder="√âcrivez vos notes ici..."></textarea>
        </div>
        <div class="drawing-notes">
          <h4>Dessin au stylet/souris</h4>
          <canvas class="drawing-canvas" width="400" height="250"></canvas>
          <div class="drawing-controls">
            <div class="color-picker">
              <div class="color-option active" style="background: #00ffff;" data-color="#00ffff"></div>
              <div class="color-option" style="background: #ffff00;" data-color="#ffff00"></div>
              <div class="color-option" style="background: #ff00ff;" data-color="#ff00ff"></div>
              <div class="color-option" style="background: #00ff00;" data-color="#00ff00"></div>
              <div class="color-option" style="background: #ffffff;" data-color="#ffffff"></div>
            </div>
            <button id="clearDrawing">Effacer</button>
            <button id="thickLine">√âpais</button>
            <button id="thinLine">Fin</button>
          </div>
        </div>
      </div>
    </div>
  </main>

  <!-- Bouton de navigation -->
  <button class="nav-button" onclick="window.location.href='index3.html'">
    üéÆ Histoire Nintendo
  </button>

  <!-- Modal Tetris -->
  <div id="tetrisModal">
    <div id="tetrisContainer">
      <button id="closeButton">√ó</button>
      <div>
        <canvas id="tetrisCanvas" width="200" height="360"></canvas>
        <div id="tetrisInfo">
          <div>Fl√®ches : D√©placer | ‚Üë : Rotation | Espace : Chute rapide</div>
          <div id="tetrisScore">Score: 0</div>
        </div>
      </div>
      <div class="tetris-sidebar">
        <div>
          <h4 style="margin: 0 0 10px 0; text-shadow: 0 0 5px #00ffff;">Prochain:</h4>
          <canvas id="nextPieceCanvas" width="80" height="80"></canvas>
        </div>
        <div>
          <h4 style="margin: 10px 0; text-shadow: 0 0 5px #00ffff;">Contr√¥les:</h4>
          <p style="font-size: 0.8em; text-align: left; margin: 5px 0;">
            ‚Üê ‚Üí : D√©placer<br>
            ‚Üë : Tourner<br>
            ‚Üì : Descendre<br>
            Espace : Poser
          </p>
        </div>
      </div>
    </div>
  </div>

  <!-- Contr√¥leur audio -->
  <div id="soundController">
    <button id="toggleMusic">‚è∏ Pause musique</button>
    <input type="range" id="volumeSlider" min="0" max="1" step="0.05" value="0.5">
    <div id="clock">--:--:--</div>
  </div>

  <script>
    // ===== INITIALISATION =====
    const startScreen = document.getElementById("startScreen");
    const skipButton = document.getElementById("skipButton");
    const introMusic = document.getElementById("introMusic");
    const bgMusic = document.getElementById("bgMusic");
    const hoverSound = document.getElementById("hoverSound");
    const clickSound = document.getElementById("clickSound");
    const vid = document.getElementById("myVideo");
    const toggleMusic = document.getElementById("toggleMusic");
    const volumeSlider = document.getElementById("volumeSlider");
    const clock = document.getElementById("clock");
    let isFading = false;

    // V√©rifier si c'est un retour (pas de chargement)
    if (sessionStorage.getItem('returningUser')) {
      startScreen.style.display = 'none';
      document.querySelector('main').style.opacity = '1';
      document.querySelector('main').style.animation = 'none';
      bgMusic.volume = 0.5;
      bgMusic.play();
    } else {
      // D√©marrage automatique avec skip direct
      window.addEventListener('load', () => {
        introMusic.volume = 0.6;
        bgMusic.volume = 0.5;
        introMusic.play();
        
        setTimeout(() => {
          skipIntro();
        }, 8000);
      });

      // Bouton skip avec transition directe
      skipButton.addEventListener("click", () => {
        playClick();
        skipIntro();
      });
    }

    function skipIntro() {
      fadeOutAudio(introMusic, 300);
      startScreen.style.animation = "fadeOut 0.8s forwards";
      setTimeout(() => {
        bgMusic.play();
        sessionStorage.setItem('returningUser', 'true');
      }, 500);
    }

    // Fade musique
    function fadeOutAudio(audio, duration = 500) {
      if (isFading) return;
      isFading = true;
      const step = audio.volume / (duration / 50);
      const fade = setInterval(() => {
        if (audio.volume > 0.05) {
          audio.volume -= step;
        } else {
          audio.volume = 0;
          audio.pause();
          clearInterval(fade);
          isFading = false;
        }
      }, 50);
    }

    function fadeInAudio(audio, targetVol = 0.5, duration = 1000) {
      if (isFading) return;
      isFading = true;
      audio.play();
      let vol = 0;
      audio.volume = 0;
      const step = targetVol / (duration / 50);
      const fade = setInterval(() => {
        if (vol < targetVol) {
          vol += step;
          audio.volume = vol;
        } else {
          audio.volume = targetVol;
          clearInterval(fade);
          isFading = false;
        }
      }, 50);
    }

    vid.addEventListener("play", () => fadeOutAudio(bgMusic, 1200));
    vid.addEventListener("pause", () => fadeInAudio(bgMusic, parseFloat(volumeSlider.value), 1200));
    vid.addEventListener("ended", () => fadeInAudio(bgMusic, parseFloat(volumeSlider.value), 1200));

    // Liens interactifs
    document.getElementById("scrollToImages").addEventListener("click", () => {
      document.getElementById("images-section").scrollIntoView({ behavior: "smooth" });
      playClick();
    });

    document.querySelectorAll("button").forEach(btn => {
      btn.addEventListener("mouseenter", () => {
        hoverSound.currentTime = 0;
        hoverSound.play();
      });
    });

    function playClick() {
      clickSound.currentTime = 0;
      clickSound.play();
    }

    // Musique / volume
    toggleMusic.addEventListener("click", () => {
      if (bgMusic.paused) {
        fadeInAudio(bgMusic, parseFloat(volumeSlider.value), 800);
        toggleMusic.textContent = "‚è∏ Pause musique";
      } else {
        fadeOutAudio(bgMusic, 800);
        toggleMusic.textContent = "‚ñ∂ Reprendre musique";
      }
      playClick();
    });

    volumeSlider.addEventListener("input", () => {
      const vol = parseFloat(volumeSlider.value);
      bgMusic.volume = vol;
      introMusic.volume = vol;
    });

    // Horloge
    setInterval(() => clock.textContent = new Date().toLocaleTimeString(), 1000);

    // ===== TETRIS AM√âLIOR√â =====
    const tetrisButton = document.getElementById("tetrisButton");
    const tetrisModal = document.getElementById("tetrisModal");
    const closeButton = document.getElementById("closeButton");
    const canvas = document.getElementById("tetrisCanvas");
    const nextPieceCanvas = document.getElementById("nextPieceCanvas");
    const ctx = canvas.getContext("2d");
    const nextCtx = nextPieceCanvas.getContext("2d");
    const scoreDisplay = document.getElementById("tetrisScore");

    const ROWS = 18;
    const COLS = 10;
    const BLOCK_SIZE = 20;
    let board = [];
    let score = 0;
    let gameActive = false;
    let currentPiece = null;
    let nextPieceObj = null;
    let gameLoop = null;

    const SHAPES = [
      [[1,1,1,1]], // I
      [[1,1],[1,1]], // O
      [[0,1,0],[1,1,1]], // T
      [[1,0,0],[1,1,1]], // L
      [[0,0,1],[1,1,1]], // J
      [[0,1,1],[1,1,0]], // S
      [[1,1,0],[0,1,1]]  // Z
    ];

    const COLORS = ['#00ffff', '#ffff00', '#ff00ff', '#00ff00', '#ff8800', '#ff0000', '#0088ff'];

    function initBoard() {
      board = Array(ROWS).fill().map(() => Array(COLS).fill(0));
      score = 0;
      scoreDisplay.textContent = `Score: ${score}`;
    }

    function drawBoard() {
      ctx.fillStyle = '#000';
      ctx.fillRect(0, 0, canvas.width, canvas.height);
      
      // Dessiner la ligne de projection
      if (gameActive && currentPiece) {
        const dropDistance = calculateDropDistance();
        if (dropDistance > 0) {
          ctx.strokeStyle = 'rgba(0, 255, 255, 0.3)';
          ctx.lineWidth = 1;
          ctx.setLineDash([5, 5]);
          currentPiece.shape.forEach((row, r) => {
            row.forEach((cell, c) => {
              if (cell) {
                const x = (currentPiece.x + c) * BLOCK_SIZE;
                const y = (currentPiece.y + r + dropDistance) * BLOCK_SIZE;
                ctx.strokeRect(x, y, BLOCK_SIZE - 1, BLOCK_SIZE - 1);
              }
            });
          });
          ctx.setLineDash([]);
        }
      }
      
      for (let r = 0; r < ROWS; r++) {
        for (let c = 0; c < COLS; c++) {
          if (board[r][c]) {
            ctx.fillStyle = COLORS[board[r][c] - 1];
            ctx.fillRect(c * BLOCK_SIZE, r * BLOCK_SIZE, BLOCK_SIZE - 1, BLOCK_SIZE - 1);
            ctx.strokeStyle = '#00ffff';
            ctx.lineWidth = 1;
            ctx.strokeRect(c * BLOCK_SIZE, r * BLOCK_SIZE, BLOCK_SIZE - 1, BLOCK_SIZE - 1);
          }
        }
      }

      if (currentPiece) {
        ctx.fillStyle = COLORS[currentPiece.color];
        currentPiece.shape.forEach((row, r) => {
          row.forEach((cell, c) => {
            if (cell) {
              const x = (currentPiece.x + c) * BLOCK_SIZE;
              const y = (currentPiece.y + r) * BLOCK_SIZE;
              ctx.fillRect(x, y, BLOCK_SIZE - 1, BLOCK_SIZE - 1);
              ctx.strokeStyle = '#00ffff';
              ctx.strokeRect(x, y, BLOCK_SIZE - 1, BLOCK_SIZE - 1);
            }
          });
        });
      }
    }

    function calculateDropDistance() {
      let dropDistance = 0;
      while (!collides(currentPiece, 0, dropDistance + 1)) {
        dropDistance++;
      }
      return dropDistance;
    }

    function drawNextPiece() {
      nextCtx.fillStyle = '#000';
      nextCtx.fillRect(0, 0, nextPieceCanvas.width, nextPieceCanvas.height);
      
      if (nextPieceObj) {
        const offsetX = (nextPieceCanvas.width - nextPieceObj.shape[0].length * BLOCK_SIZE/2) / 2;
        const offsetY = (nextPieceCanvas.height - nextPieceObj.shape.length * BLOCK_SIZE/2) / 2;
        
        nextCtx.fillStyle = COLORS[nextPieceObj.color];
        nextPieceObj.shape.forEach((row, r) => {
          row.forEach((cell, c) => {
            if (cell) {
              const x = offsetX + c * BLOCK_SIZE/2;
              const y = offsetY + r * BLOCK_SIZE/2;
              nextCtx.fillRect(x, y, BLOCK_SIZE/2 - 1, BLOCK_SIZE/2 - 1);
              nextCtx.strokeStyle = '#00ffff';
              nextCtx.strokeRect(x, y, BLOCK_SIZE/2 - 1, BLOCK_SIZE/2 - 1);
            }
          });
        });
      }
    }

    function createPiece() {
      const shapeIndex = Math.floor(Math.random() * SHAPES.length);
      return {
        shape: SHAPES[shapeIndex],
        color: shapeIndex,
        x: Math.floor(COLS / 2) - 1,
        y: 0
      };
    }

    function collides(piece, offsetX = 0, offsetY = 0) {
      for (let r = 0; r < piece.shape.length; r++) {
        for (let c = 0; c < piece.shape[r].length; c++) {
          if (piece.shape[r][c]) {
            const newX = piece.x + c + offsetX;
            const newY = piece.y + r + offsetY;
            if (newX < 0 || newX >= COLS || newY >= ROWS) return true;
            if (newY >= 0 && board[newY][newX]) return true;
          }
        }
      }
      return false;
    }

    // Fonction pour cr√©er des particules
    function createParticles(x, y, count = 8) {
      for (let i = 0; i < count; i++) {
        const particle = document.createElement('div');
        particle.className = 'tetris-particle';
        particle.style.left = `${x}px`;
        particle.style.top = `${y}px`;
        document.body.appendChild(particle);
        
        const angle = Math.random() * Math.PI * 2;
        const distance = Math.random() * 30 + 10;
        const targetX = x + Math.cos(angle) * distance;
        const targetY = y + Math.sin(angle) * distance;
        
        particle.style.animation = `particle-fall ${Math.random() * 0.5 + 0.3}s ease forwards`;
        particle.style.left = `${targetX}px`;
        
        setTimeout(() => {
          if (particle.parentNode) {
            particle.parentNode.removeChild(particle);
          }
        }, 500);
      }
    }

    function mergePiece() {
      // Cr√©er des particules √† chaque bloc pos√©
      currentPiece.shape.forEach((row, r) => {
        row.forEach((cell, c) => {
          if (cell) {
            const y = currentPiece.y + r;
            const x = currentPiece.x + c;
            if (y >= 0) {
              board[y][x] = currentPiece.color + 1;
              // Cr√©er des particules √† la position du bloc
              const canvasRect = canvas.getBoundingClientRect();
              const particleX = canvasRect.left + x * BLOCK_SIZE + BLOCK_SIZE/2;
              const particleY = canvasRect.top + y * BLOCK_SIZE + BLOCK_SIZE/2;
              createParticles(particleX, particleY, 3);
            }
          }
        });
      });
    }

    function clearLines() {
      let linesCleared = 0;
      for (let r = ROWS - 1; r >= 0; r--) {
        if (board[r].every(cell => cell !== 0)) {
          // Cr√©er plus de particules pour une ligne compl√®te
          for (let c = 0; c < COLS; c++) {
            const canvasRect = canvas.getBoundingClientRect();
            const particleX = canvasRect.left + c * BLOCK_SIZE + BLOCK_SIZE/2;
            const particleY = canvasRect.top + r * BLOCK_SIZE + BLOCK_SIZE/2;
            createParticles(particleX, particleY, 5);
          }
          
          board.splice(r, 1);
          board.unshift(Array(COLS).fill(0));
          linesCleared++;
          r++;
        }
      }
      if (linesCleared > 0) {
        score += linesCleared * 100;
        scoreDisplay.textContent = `Score: ${score}`;
      }
    }

    function rotatePiece() {
      const rotated = currentPiece.shape[0].map((_, i) =>
        currentPiece.shape.map(row => row[i]).reverse()
      );
      const oldShape = currentPiece.shape;
      currentPiece.shape = rotated;
      if (collides(currentPiece)) {
        currentPiece.shape = oldShape;
      }
    }

    function hardDrop() {
      // Animation de flash
      canvas.classList.add('hard-drop-animation');
      setTimeout(() => {
        canvas.classList.remove('hard-drop-animation');
      }, 300);
      
      const dropDistance = calculateDropDistance();
      currentPiece.y += dropDistance;
      mergePiece();
      clearLines();
      currentPiece = nextPieceObj;
      nextPieceObj = createPiece();
      drawNextPiece();
      
      if (collides(currentPiece)) {
        gameActive = false;
        clearInterval(gameLoop);
        alert(`Game Over! Score: ${score}`);
        tetrisModal.classList.remove("active");
      }
    }

    function gameStep() {
      if (!collides(currentPiece, 0, 1)) {
        currentPiece.y++;
      } else {
        mergePiece();
        clearLines();
        currentPiece = nextPieceObj;
        nextPieceObj = createPiece();
        drawNextPiece();
        if (collides(currentPiece)) {
          gameActive = false;
          clearInterval(gameLoop);
          alert(`Game Over! Score: ${score}`);
          tetrisModal.classList.remove("active");
        }
      }
      drawBoard();
    }

    function startGame() {
      initBoard();
      currentPiece = createPiece();
      nextPieceObj = createPiece();
      gameActive = true;
      drawBoard();
      drawNextPiece();
      gameLoop = setInterval(gameStep, 500);
    }

    tetrisButton.addEventListener("click", () => {
      playClick();
      tetrisModal.classList.add("active");
      startGame();
    });

    closeButton.addEventListener("click", () => {
      playClick();
      tetrisModal.classList.remove("active");
      gameActive = false;
      if (gameLoop) clearInterval(gameLoop);
    });

    document.addEventListener("keydown", (e) => {
      if (!gameActive) return;
      
      // Emp√™cher le scroll de la page avec les fl√®ches
      if (["ArrowLeft", "ArrowRight", "ArrowDown", "ArrowUp", " "].includes(e.key)) {
        e.preventDefault();
      }
      
      if (e.key === "ArrowLeft" && !collides(currentPiece, -1, 0)) {
        currentPiece.x--;
      } else if (e.key === "ArrowRight" && !collides(currentPiece, 1, 0)) {
        currentPiece.x++;
      } else if (e.key === "ArrowDown" && !collides(currentPiece, 0, 1)) {
        currentPiece.y++;
      } else if (e.key === "ArrowUp") {
        rotatePiece();
      } else if (e.key === " ") {
        hardDrop();
      }
      drawBoard();
    });

    tetrisModal.addEventListener("click", (e) => {
      if (e.target === tetrisModal) {
        tetrisModal.classList.remove("active");
        gameActive = false;
        if (gameLoop) clearInterval(gameLoop);
      }
    });

    // ===== ZONE DE NOTES AVEC DESSIN =====
    const drawingCanvas = document.querySelector('.drawing-canvas');
    const drawingCtx = drawingCanvas.getContext('2d');
    const clearButton = document.getElementById('clearDrawing');
    const thickButton = document.getElementById('thickLine');
    const thinButton = document.getElementById('thinLine');
    const colorOptions = document.querySelectorAll('.color-option');
    
    let isDrawing = false;
    let lastX = 0;
    let lastY = 0;
    let currentColor = '#00ffff';
    let lineWidth = 2;

    // Initialiser le canvas de dessin
    drawingCtx.fillStyle = 'rgba(0, 0, 0, 0.5)';
    drawingCtx.fillRect(0, 0, drawingCanvas.width, drawingCanvas.height);
    drawingCtx.lineJoin = 'round';
    drawingCtx.lineCap = 'round';
    drawingCtx.strokeStyle = currentColor;
    drawingCtx.lineWidth = lineWidth;

    // √âv√©nements de dessin
    drawingCanvas.addEventListener('mousedown', startDrawing);
    drawingCanvas.addEventListener('mousemove', draw);
    drawingCanvas.addEventListener('mouseup', stopDrawing);
    drawingCanvas.addEventListener('mouseout', stopDrawing);

    // Support pour les stylets (touch)
    drawingCanvas.addEventListener('touchstart', handleTouch);
    drawingCanvas.addEventListener('touchmove', handleTouch);
    drawingCanvas.addEventListener('touchend', stopDrawing);

    function handleTouch(e) {
      e.preventDefault();
      const touch = e.touches[0];
      const mouseEvent = new MouseEvent('mousedown', {
        clientX: touch.clientX,
        clientY: touch.clientY
      });
      drawingCanvas.dispatchEvent(mouseEvent);
    }

    function startDrawing(e) {
      isDrawing = true;
      [lastX, lastY] = [e.offsetX, e.offsetY];
    }

    function draw(e) {
      if (!isDrawing) return;
      
      drawingCtx.beginPath();
      drawingCtx.moveTo(lastX, lastY);
      drawingCtx.lineTo(e.offsetX, e.offsetY);
      drawingCtx.stroke();
      
      [lastX, lastY] = [e.offsetX, e.offsetY];
    }

    function stopDrawing() {
      isDrawing = false;
    }

    // Contr√¥les de dessin
    clearButton.addEventListener('click', () => {
      drawingCtx.fillStyle = 'rgba(0, 0, 0, 0.5)';
      drawingCtx.fillRect(0, 0, drawingCanvas.width, drawingCanvas.height);
    });

    thickButton.addEventListener('click', () => {
      lineWidth = 5;
      drawingCtx.lineWidth = lineWidth;
    });

    thinButton.addEventListener('click', () => {
      lineWidth = 2;
      drawingCtx.lineWidth = lineWidth;
    });

    colorOptions.forEach(option => {
      option.addEventListener('click', () => {
        colorOptions.forEach(opt => opt.classList.remove('active'));
        option.classList.add('active');
        currentColor = option.dataset.color;
        drawingCtx.strokeStyle = currentColor;
      });
    });

    // ===== EFFET DE FLOU GRADUEL EN BAS =====
    class GradualBlur {
      constructor(options = {}) {
        this.position = options.position || 'bottom';
        this.strength = options.strength || 3;
        this.init();
      }
      
      init() {
        const overlay = document.createElement('div');
        overlay.style.position = 'fixed';
        overlay.style.left = '0';
        overlay.style.right = '0';
        overlay.style.height = '100px';
        overlay.style.pointerEvents = 'none';
        overlay.style.zIndex = '999';
        
        if (this.position === 'bottom') {
          overlay.style.bottom = '0';
          overlay.style.background = 'linear-gradient(to top, rgba(11,11,11,0.8), transparent)';
        } else {
          overlay.style.top = '0';
          overlay.style.background = 'linear-gradient(to bottom, rgba(11,11,11,0.8), transparent)';
        }
        
        document.body.appendChild(overlay);
      }
    }

    // Initialiser l'effet de flou
    const pageBlur = new GradualBlur({
      position: 'bottom',
      strength: 2
    });

    console.log('‚ú® Site charg√© avec succ√®s !');
  </script>
</body>
</html>
